<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Drone Dashboard</title>

  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="/uPlot.min.css">
  <style>
    :root { --gap:12px; --green:#10b981; --red:#ef4444; --amber:#f59e0b; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:12px; background:#fff; color:#111; }
    h2 { margin: 0 0 12px 0; display:inline-block; vertical-align:middle; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
    .card { padding:12px; border-radius:14px; box-shadow:0 6px 20px rgba(0,0,0,.08); background:#f9fafb; }
    .ctrl { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .ctrl input[type="number"] { width:100px; padding:6px 8px; border-radius:10px; border:1px solid #ddd; background:#fff; color:#111; }
    .btn { padding:8px 12px; border:0; border-radius:10px; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.1); background:#fff; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    #compass { width:260px; height:260px; background:#fff; }
    .banner-error { background:#fee2e2; color:#991b1b; padding:10px; border-radius:10px; margin-bottom:12px; display:none; white-space:pre-wrap; }
    @media (max-width: 900px){ .grid { grid-template-columns: 1fr; } }

    /* conexión */
    .conn-wrap { display:flex; align-items:center; gap:12px; margin-left:12px; vertical-align:middle; }
    .conn-ind { display:inline-flex; align-items:center; gap:12px; padding:8px 14px; border-radius:14px; font-weight:700; font-size:1.05rem; box-shadow:0 6px 18px rgba(0,0,0,.06); background:#fff; border:1px solid rgba(0,0,0,0.06); }
    .conn-ind .dot { width:14px; height:14px; border-radius:50%; box-shadow:0 0 10px rgba(0,0,0,0.06); flex:0 0 14px; }
    .conn-ind.connected { color: var(--green); border-color: rgba(16,185,129,.12); }
    .conn-ind.connected .dot { background: var(--green); box-shadow:0 0 14px rgba(16,185,129,.45); }
    .conn-ind.connecting { color: var(--amber); border-color: rgba(245,158,11,.12); }
    .conn-ind.connecting .dot { background: var(--amber); animation: pulse 1.2s infinite; box-shadow:0 0 12px rgba(245,158,11,.35); }
    .conn-ind.disconnected { color: var(--red); border-color: rgba(239,68,68,.08); }
    .conn-ind.disconnected .dot { background: var(--red); box-shadow:0 0 12px rgba(239,68,68,.25); }

    @keyframes pulse { 0%{transform:scale(1);opacity:1;} 50%{transform:scale(1.12);opacity:.75;} 100%{transform:scale(1);opacity:1;} }

    /* Overlay diag */
    #diag {
      position: fixed; right: 10px; bottom: 10px; z-index: 9999;
      background: rgba(255,255,255,.95); border:1px solid rgba(0,0,0,.1);
      border-radius:10px; padding:8px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:.85rem; box-shadow:0 6px 18px rgba(0,0,0,.06);
    }
    #diag span { display:inline-block; min-width: 48px; text-align:right; }
  </style>
</head>
<body>
  <div style="display:flex; align-items:center; gap:18px;">
    <h2>Drone Dashboard</h2>
    <div class="conn-wrap" aria-live="polite" aria-atomic="true">
      <div id="connIndicator" class="conn-ind disconnected" role="status" title="Estado de conexión">
        <div class="dot disconnected" aria-hidden="true"></div>
        <div class="conn-text">
          <div class="conn-main" id="connLabel">Desconectado</div>
          <div class="conn-sub" id="connMeta">último paquete: —</div>
        </div>
      </div>
    </div>
  </div>

  <div id="err" class="banner-error"></div>

  <!-- <--- CAMBIO: Layout de controles modificado para Armar/Desarmar --->
  <div class="card ctrl">
    <div class="row">
      <label>Setpoint altura (cm):
        <input id="sp" type="number" value="120" min="0" max="300"/>
      </label>
      <button id="apply" class="btn">Aplicar</button>
    </div>
    <div class="row" style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;">
      <button id="btnArm" class="btn" style="background-color: var(--amber); color: #333; font-weight: 600;">Armar Motores</button>
      <button id="btnDisarm" class="btn" style="background-color: var(--red); color: white; font-weight: 700; transform: scale(1.05);">¡APAGAR MOTORES!</button>
    </div>
  </div>

  <div class="grid">
    <div class="card"><div id="gAlt" style="height:260px"></div></div>
    <div class="card"><div id="gAtt" style="height:260px"></div></div>
  </div>

  <div class="card">
    <canvas id="compass" width="260" height="260"></canvas>
  </div>

  <div class="card" id="readouts">
    <div class="row" style="gap:16px; flex-wrap:wrap">
      <div id="altVal">Altura – cm</div>
      <div id="yawVal">Yaw – °</div>
      <div id="pitchVal">Pitch – °</div>
      <div id="rollVal">Roll – °</div>
      <div id="hdgVal">Direccion – °</div>
      <div id="spVal">Setpoint 120 cm</div>
      <div id="armVal" style="font-weight: 700; color: var(--red);">Estado: DESARMADO</div> <!-- <--- CAMBIO: Indicador de estado -->
    </div>
  </div>

  <!-- Overlay diagnóstico -->
  <div id="diag">pps: <span id="pps">0</span> | seq: <span id="seq">—</span> | len: <span id="len">—</span> | dt: <span id="dt">—</span> ms</div>

  <script src="/uPlot.iife.min.js" onerror="
    (function(){
      var e = document.getElementById('err');
      e.style.display='block';
      e.textContent = 'No se pudo cargar /uPlot.iife.min.js desde el ESP32.\nAsegúrate de subir uPlot.iife.min.js y uPlot.min.css a /data y vuelve a cargar.';
    })();"></script>

<script>
(function(){
  const errBox = document.getElementById('err');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent = msg; console.error(msg); }

  const HOST = window.location.hostname || '192.168.4.1';
  const BASE_URL = `http://${HOST}`;
  const WS_URL = `ws://${HOST}/ws`;
  
  // <--- CAMBIO: Eliminada la bandera isManualDisconnect
  let ws;

  // ---------- elementos ----------
  const setBtn = document.getElementById('apply');
  const spInput = document.getElementById('sp');
  const altVal  = document.getElementById('altVal');
  const yawVal  = document.getElementById('yawVal');
  const pitchVal= document.getElementById('pitchVal');
  const rollVal = document.getElementById('rollVal');
  const hdgVal  = document.getElementById('hdgVal');
  const spVal   = document.getElementById('spVal');
  const armVal  = document.getElementById('armVal'); // <--- CAMBIO: Indicador de estado
  
  // <--- CAMBIO: Nuevos botones
  const btnArm = document.getElementById('btnArm');
  const btnDisarm = document.getElementById('btnDisarm');

  const connEl = document.getElementById('connIndicator');
  const connDot = connEl.querySelector('.dot');
  const connLabel = document.getElementById('connLabel');
  const connMeta = document.getElementById('connMeta');

  // overlay diag
  const ppsEl = document.getElementById('pps');
  const seqEl = document.getElementById('seq');
  const lenEl = document.getElementById('len');
  const dtEl  = document.getElementById('dt');

  // <--- CAMBIO: Bit de Flag para "ARMADO" (debe coincidir con el C++)
  const FLAG_ARMED_BIT = (1 << 0); // Bit 0

  const cur = { alt:null, yaw:null, pitch:null, roll:null, hdg:null, sp: parseInt(spInput.value,10) || 120, flags: 0 };

  // ---------- uPlot opcional ----------
  // ... (código uPlot sin cambios) ...
  const urlParams = new URLSearchParams(location.search);
  const forceNoUPlot = urlParams.has('nouplot');
  const hasUPlot = !!window.uPlot && !forceNoUPlot;
  const seriesColors = ['#2563eb','#10b981','#f59e0b']; // yaw, pitch, roll
  const N = 300;
  const tBuf = new Float32Array(N);
  const altBuf  = new Float32Array(N);
  const yawBuf  = new Float32Array(N);
  const pitBuf  = new Float32Array(N);
  const rolBuf  = new Float32Array(N);
  let wr=0, filled=0;
  let lastT = 0;
  function nowSec(){ return performance.now()/1000; }
  function pushPoint(t, alt, yaw, pit, rol){
    if (t <= lastT) t = lastT + 1e-6; // evita t iguales o decrecientes
    lastT = t;
    tBuf[wr]=t; altBuf[wr]=alt; yawBuf[wr]=yaw; pitBuf[wr]=pit; rolBuf[wr]=rol;
    wr = (wr+1) % N; if (filled < N) filled++;
  }
  function ordered(buf){
    if (filled < N) return buf.subarray(0, filled);
    const a = buf.subarray(wr), b = buf.subarray(0, wr);
    const out = new Float32Array(a.length + b.length);
    out.set(a,0); out.set(b,a.length);
    return out;
  }
  let uAlt=null, uAtt=null;
  if (hasUPlot) {
    try {
      uAlt = new uPlot({
        width: Math.min(560, window.innerWidth-64), height: 240, spanGaps: true,
        series: [
          {}, // x
          { label:"Altura (cm)", width:2, stroke:'#111' } // color explícito
        ],
        axes: [{}, {label:"cm"}],
        scales:{x:{time:false}},
        legend: { show: true, live: false, values: [] }
      }, [[],[]], document.getElementById('gAlt'));
      uAtt = new uPlot({
        width: Math.min(560, window.innerWidth-64), height: 240, spanGaps: true,
        series: [
          {},
          { label:"Yaw (°)"  , width:2, stroke: seriesColors[0] },
          { label:"Pitch (°)", width:2, stroke: seriesColors[1] },
          { label:"Roll (°)" , width:2,  stroke: seriesColors[2] }
        ],
        axes: [{}, {label:"°"}],
        scales:{x:{time:false}},
        legend: { show: true, live: false, values: [] }
      }, [[],[],[],[]], document.getElementById('gAtt'));
    } catch(e) {
      showErr("Error inicializando uPlot: " + e.message);
    }
  } else {
    document.getElementById('gAlt').textContent = "uPlot no disponible (usa ?nouplot=1 o sube uPlot.iife.min.js)";
    document.getElementById('gAtt').textContent = "uPlot no disponible";
  }
  let needDraw=false, lastDraw=0;
  function redraw(){
    const tData   = Array.from(ordered(tBuf));
    const altData = Array.from(ordered(altBuf));
    const yawData = Array.from(ordered(yawBuf));
    const pitData = Array.from(ordered(pitBuf));
    const rolData = Array.from(ordered(rolBuf));
    if (uAlt) uAlt.setData([tData, altData]);
    if (uAtt) uAtt.setData([tData, yawData, pitData, rolData]);
  }
  function scheduleDraw(){
    const now = performance.now();
    if (now - lastDraw < 50) return; // ~20 FPS
    if (needDraw) return;
    needDraw = true;
    requestAnimationFrame(()=>{ needDraw=false; lastDraw=performance.now(); redraw(); });
  }
  window.addEventListener('resize', () => {
    if (uAlt) uAlt.setSize({width: Math.min(560, window.innerWidth-64), height: 240});
    if (uAtt) uAtt.setSize({width: Math.min(560, window.innerWidth-64), height: 240});
  });

  // brújula
  // ... (código brújula sin cambios) ...
  function drawCompass(hdg){
    const c = document.getElementById('compass');
    const ctx = c.getContext('2d');
    const W = c.width, H = c.height;
    ctx.clearRect(0,0,W,H);
    const cx=W/2, cy=H/2, R=Math.min(W,H)/2-18;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();
    ctx.font = '14px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('N', cx, cy-R+12); ctx.fillText('S', cx, cy+R-12);
    ctx.fillText('E', cx+R-12, cy); ctx.fillText('O', cx-R+12, cy);
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(hdg*Math.PI/180);
    ctx.beginPath(); ctx.moveTo(0,-R+10); ctx.lineTo(6,12); ctx.lineTo(-6,12); ctx.closePath(); ctx.stroke();
    ctx.restore();
  }

  // lecturas texto
  function renderReadouts(){
    altVal.textContent   = "Altura "  + (Number.isFinite(cur.alt)   ? cur.alt.toFixed(0)   : "–") + " cm";
    yawVal.textContent   = "Yaw "     + (Number.isFinite(cur.yaw)   ? cur.yaw.toFixed(1)   : "–") + " °";
    pitchVal.textContent = "Pitch "   + (Number.isFinite(cur.pitch) ? cur.pitch.toFixed(1) : "–") + " °";
    rollVal.textContent  = "Roll "    + (Number.isFinite(cur.roll)  ? cur.roll.toFixed(1)  : "–") + " °";
    hdgVal.textContent   = "Direccion " + (Number.isFinite(cur.hdg) ? cur.hdg.toFixed(1)   : "–") + " °";
    spVal.textContent    = "Setpoint " + (Number.isFinite(cur.sp)   ? cur.sp.toFixed(0)    : "–") + " cm";
    
    // <--- CAMBIO: Actualizar indicador de estado
    const isArmed = (cur.flags & FLAG_ARMED_BIT) > 0;
    if (isArmed) {
      armVal.textContent = "Estado: ¡ARMADO!";
      armVal.style.color = 'var(--green)';
    } else {
      armVal.textContent = "Estado: DESARMADO";
      armVal.style.color = 'var(--red)';
    }
  }

  // estado conexion
  let lastPacketAt=0, lastSeenOnClose=0;
  function ageStr(msDiff){ if (!msDiff || msDiff<0) return '—'; const s=msDiff/1000; return s.toFixed(2)+' s'; }
  function setConnState(state){
    connEl.classList.remove('connected','connecting','disconnected');
    connDot.classList.remove('connected','connecting','disconnected');
    connEl.classList.add(state); connDot.classList.add(state);
    connLabel.textContent = state==='connected' ? 'Conectado ✔' : state==='connecting' ? 'Conectando…' : 'Desconectado';
    const now = Date.now();
    if (lastPacketAt) connMeta.textContent = 'activo hace ' + ageStr(now-lastPacketAt);
    else if (lastSeenOnClose) connMeta.textContent = 'último cierre: ' + ageStr(now-lastSeenOnClose);
    else connMeta.textContent = 'último paquete: —';
  }
  setConnState('disconnected');

  // simulador (se apaga con WS real)
  let simTimer=null, syaw=0, spitch=0, sroll=0, salt=120, shdg=0, simSp=cur.sp;
  function simStep(){
    syaw += (Math.random()-0.5)*1.2; spitch += (Math.random()-0.5)*1.0; sroll += (Math.random()-0.5)*1.0;
    shdg += (Math.random()-0.5)*3.0; if (shdg<0) shdg+=360; if (shdg>=360) shdg-=360;
    const err = simSp - salt; salt += 0.15*err + (Math.random()-0.5)*0.8;
    salt = Math.max(0, Math.min(300, salt)); spitch = Math.max(-45, Math.min(45, spitch)); sroll = Math.max(-45, Math.min(45, sroll));
    const tsec = nowSec(); pushPoint(tsec, salt, syaw, spitch, sroll);
    cur.yaw=syaw; cur.pitch=spitch; cur.roll=sroll; cur.alt=salt; cur.hdg=shdg; cur.flags=0; // Sim siempre desarmado
    drawCompass(shdg); renderReadouts(); scheduleDraw();
  }
  function startSim(){ if (!simTimer){ simTimer = setInterval(simStep, 40); setConnState('disconnected'); } }
  function stopSim(){ if (simTimer){ clearInterval(simTimer); simTimer=null; } }

  // pps/seq diagnostico
  let lastSeq = null, msgsThisSec=0, lastMsgTime=null;
  setInterval(()=>{ ppsEl.textContent = msgsThisSec.toString(); msgsThisSec = 0; }, 1000);

  // parseo
  // ... (código parseTelemetryBuf sin cambios, ya es correcto para 8 bytes) ...
  function parseTelemetryBuf(buf){
    const dv = new DataView(buf);
    const len = dv.byteLength;
    lenEl.textContent = String(len);
    if (len === 8) {
      let off=0;
      const yaw_c   = dv.getInt16(off, true); off+=2;
      const pitch_d = dv.getInt8(off);         off+=1;
      const roll_d  = dv.getInt8(off);         off+=1;
      const alt_cm  = dv.getUint16(off,true); off+=2;
      const flags   = dv.getUint8(off);        off+=1;
      const seq     = dv.getUint8(off);        off+=1;
      return { yaw: yaw_c/100, pitch: pitch_d, roll: roll_d, alt: alt_cm, hdg: ((yaw_c/100)%360+360)%360, seq, flags };
    }
    // ... (fallbacks para 10 y 14 bytes) ...
    if (len === 10) {
      let off=0;
      const yaw_c   = dv.getInt16(off,true); off+=2;
      const pitch_c = dv.getInt16(off,true); off+=2;
      const roll_c  = dv.getInt16(off,true); off+=2;
      const alt_cm  = dv.getUint16(off,true);off+=2;
      const seq     = dv.getUint8(off);      off+=1; // opcional
      const flags   = dv.getUint8(off) || 0;
      return { yaw: yaw_c/100, pitch: pitch_c/100, roll: roll_c/100, alt: alt_cm, hdg: ((yaw_c/100)%360+360)%360, seq, flags };
    }
    if (len >= 14) {
      const yaw_c   = dv.getInt16( 4, true);
      const pitch_c = dv.getInt16( 6, true);
      const roll_c  = dv.getInt16( 8, true);
      const alt_cm  = dv.getInt16(10, true);
      const hdg_c   = dv.getInt16(12, true);
      const seq     = len>14 ? dv.getUint8(14) : 0;
      const flags   = len>15 ? dv.getUint8(15) : 0;
      return { yaw: yaw_c/100, pitch: pitch_c/100, roll: roll_c/100, alt: alt_cm, hdg: hdg_c/100, seq, flags };
    }
    return null;
  }

  function connectWS(){
    // <--- CAMBIO: Lógica de conexión simplificada (sin isManualDisconnect)
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
      console.log('connectWS abortado: Ya conectado o conectando.');
      return; 
    }

    setConnState('connecting');
    try { 
      ws = new WebSocket(WS_URL); 
    } catch(e){ 
      showErr('WS init: '+e.message); 
      startSim(); 
      setTimeout(connectWS, 1000); // Intenta de nuevo
      return; 
    }
    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
      stopSim(); lastPacketAt = Date.now(); setConnState('connected');
      try { ws.send(new Uint8Array([0xFF,0xFF])); } catch(_) {}
    };

    // <--- CAMBIO: onclose ahora SIEMPRE intenta reconectar
    ws.onclose = () => { 
      lastSeenOnClose = Date.now(); 
      setConnState('disconnected'); 
      startSim(); 
      console.log('WS cerrado, intentando reconectar en 1s...');
      setTimeout(connectWS, 1000); 
    };
    ws.onerror = (e) => { showErr('WS error (ver consola).'); console.error(e); };

    ws.onmessage = (ev) => {
      lastPacketAt = Date.now();
      if (!(ev.data instanceof ArrayBuffer)) {
        // ... (JSON hello/sp) ...
        try {
          const obj = JSON.parse(ev.data);
          if ('sp' in obj) { spInput.value = obj.sp; cur.sp = obj.sp; renderReadouts(); }
        } catch(_) {}
        return;
      }

      const now = performance.now();
      const dt = lastMsgTime == null ? 0 : (now - lastMsgTime);
      lastMsgTime = now;
      dtEl.textContent = dt.toFixed(1);

      const t = parseTelemetryBuf(ev.data);
      if (!t) return;

      msgsThisSec++;
      seqEl.textContent = t.seq ?? '—';

      const yaw_deg = t.yaw, pitch_deg = t.pitch, roll_deg = t.roll, alt = t.alt;
      const hdg_deg = t.hdg;
      const flags = t.flags; // <--- CAMBIO: Leer flags

      // push + UI
      pushPoint(nowSec(), alt, yaw_deg, pitch_deg, roll_deg);
      drawCompass(hdg_deg);
      cur.yaw=yaw_deg; cur.pitch=pitch_deg; cur.roll=roll_deg; cur.alt=alt; cur.hdg=hdg_deg; cur.flags=flags; // <--- CAMBIO: Guardar flags
      renderReadouts();
      scheduleDraw();
    };
  }

  // setpoint
setBtn.onclick = () => {
  const sp = Math.max(0, Math.min(300, parseInt(spInput.value || "0", 10)));
  cur.sp = sp;
  renderReadouts();
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    setConnState("disconnected");
    return;
  }
  const msg = "ALT:" + String(sp);
  ws.send(msg);
};

  
  // <--- CAMBIO: Handlers para los botones Armar/Desarmar
  btnArm.onclick = async () => {
    console.log('Botón Armar presionado.');
    try {
      await fetch(BASE_URL + '/arm');
      console.log('Comando /arm enviado.');
    } catch (e) {
      showErr('Error al llamar a /arm: ' + e.message);
    }
  };

  btnDisarm.onclick = async () => {
    console.log('Botón APAGAR MOTORES presionado.');
    try {
      await fetch(BASE_URL + '/disarm');
      console.log('Comando /disarm (KILL SWITCH) enviado.');
    } catch (e) {
      showErr('Error al llamar a /disarm: ' + e.message);
    }
  };


  // conexión meta updater
  // <--- CAMBIO: Lógica simplificada (sin isManualDisconnect)
  setInterval(()=>{
    const now = Date.now();
    if (lastPacketAt && (now - lastPacketAt) < 3000) {
      if (ws && ws.readyState===WebSocket.OPEN) setConnState('connected');
      else setConnState('connecting');
    } else {
      setConnState('disconnected');
    }
  }, 300);

  // arranque
  window.addEventListener('load', () => {
    renderReadouts();
    startSim();     // muestra algo inmediatamente
    connectWS();    // se apaga el simulador al abrir WS real
  });
})();
</script>
</body>
</html>